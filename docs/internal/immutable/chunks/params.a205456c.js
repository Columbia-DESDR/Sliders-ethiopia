import{M as o}from"./index.18be492a.js";import{i as l,X as n,U as c}from"./database.7337c015.js";import{w as u}from"./paths.088b2208.js";let y={climatology:{name:"climatology",query:"with __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ),source as ( select * from __dbt__cte__chirps ), climatology as ( select dekad, avg(value_cap) as average_value from source group by dekad order by dekad ) select * from climatology"},crop_cal:{name:"crop_cal",query:"with __dbt__cte__crop_cal_precast as ( SELECT gid, crop, activity, GREATEST((start_time - DATE '2020-01-01')/10, 1) as start_time, GREATEST((end_time - DATE '2020-01-01')/10, 1) as end_time FROM crop_cal_raw WHERE gid='var(region)' )SELECT gid, crop, activity, start_time::INTEGER AS start_time, end_time::INTEGER AS end_time FROM __dbt__cte__crop_cal_precast"},vegetation_chirps:{name:"vegetation_chirps",query:"with __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ),source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(vegetation_first) and dekad <= var(vegetation_last) ), rain_window as ( select year, sum(value) *var(scalar_vegetation) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output"},payout_sum_late:{name:"payout_sum_late",query:"with __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__sum_late as ( with source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_late_first) and dekad <= var(sum_late_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ),source as ( select * from __dbt__cte__sum_late ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output"},chirps:{name:"chirps",query:"with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output"},matching:{name:"matching",query:"with __dbt__cte__badyear as ( SELECT * FROM badyear_raw WHERE gid='var(region)' AND is_bad_year = 1 ORDER BY variable ), __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__sum_early as ( with source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_early_first) and dekad <= var(sum_early_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_sum_early as ( with source as ( select * from __dbt__cte__sum_early ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ), __dbt__cte__sum_late as ( with source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_late_first) and dekad <= var(sum_late_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_sum_late as ( with source as ( select * from __dbt__cte__sum_late ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ), __dbt__cte__evi as ( with unpivot_result as ( select * from evi_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__vegetation_evi as ( with source as ( select * from __dbt__cte__evi ), intervel as ( select * from source where dekad >= var(vegetation_first) and dekad <= var(vegetation_last) ), rain_window as ( select year, sum(value) *var(scalar_vegetation) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_vegetation_evi as ( with source as ( select * from __dbt__cte__vegetation_evi ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ), __dbt__cte__payout_combined as ( with source as ( select a.year as year, var(sum_early_weight)*a.payout + var(vegetation_weight)*GREATEST(b.payout,c.payout) as combined_payout, a.payout as sum_early, b.payout as sum_late, c.payout as vegetation from __dbt__cte__payout_sum_early a join __dbt__cte__payout_sum_late b on a.year = b.year left join __dbt__cte__payout_vegetation_evi c on a.year = c.year ) select * from source )SELECT a.gid, b.year, a.is_bad_year, b.combined_payout, b.sum_early, b.sum_late, b.vegetation FROM __dbt__cte__badyear a RIGHT JOIN __dbt__cte__payout_combined b ON a.year = b.year"},evi:{name:"evi",query:"with unpivot_result as ( select * from evi_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output"},badyear:{name:"badyear",query:"SELECT * FROM badyear_raw WHERE gid='var(region)' AND is_bad_year = 1 ORDER BY variable"},payout_combined:{name:"payout_combined",query:"with __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__sum_early as ( with source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_early_first) and dekad <= var(sum_early_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_sum_early as ( with source as ( select * from __dbt__cte__sum_early ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ), __dbt__cte__sum_late as ( with source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_late_first) and dekad <= var(sum_late_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_sum_late as ( with source as ( select * from __dbt__cte__sum_late ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ), __dbt__cte__evi as ( with unpivot_result as ( select * from evi_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__vegetation_evi as ( with source as ( select * from __dbt__cte__evi ), intervel as ( select * from source where dekad >= var(vegetation_first) and dekad <= var(vegetation_last) ), rain_window as ( select year, sum(value) *var(scalar_vegetation) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_vegetation_evi as ( with source as ( select * from __dbt__cte__vegetation_evi ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ),source as ( select a.year as year, var(sum_early_weight)*a.payout + var(vegetation_weight)*GREATEST(b.payout,c.payout) as combined_payout, a.payout as sum_early, b.payout as sum_late, c.payout as vegetation from __dbt__cte__payout_sum_early a join __dbt__cte__payout_sum_late b on a.year = b.year left join __dbt__cte__payout_vegetation_evi c on a.year = c.year ) select * from source"},check:{name:"check",query:"with __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__sum_early as ( with source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_early_first) and dekad <= var(sum_early_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_sum_early as ( with source as ( select * from __dbt__cte__sum_early ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ), __dbt__cte__sum_late as ( with source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_late_first) and dekad <= var(sum_late_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_sum_late as ( with source as ( select * from __dbt__cte__sum_late ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ), __dbt__cte__evi as ( with unpivot_result as ( select * from evi_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__vegetation_evi as ( with source as ( select * from __dbt__cte__evi ), intervel as ( select * from source where dekad >= var(vegetation_first) and dekad <= var(vegetation_last) ), rain_window as ( select year, sum(value) *var(scalar_vegetation) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ), __dbt__cte__payout_vegetation_evi as ( with source as ( select * from __dbt__cte__vegetation_evi ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output ), __dbt__cte__payout_combined as ( with source as ( select a.year as year, var(sum_early_weight)*a.payout + var(vegetation_weight)*GREATEST(b.payout,c.payout) as combined_payout, a.payout as sum_early, b.payout as sum_late, c.payout as vegetation from __dbt__cte__payout_sum_early a join __dbt__cte__payout_sum_late b on a.year = b.year left join __dbt__cte__payout_vegetation_evi c on a.year = c.year ) select * from source )select sum(a.combined_payout) from __dbt__cte__payout_combined a"},payout_sum_early:{name:"payout_sum_early",query:"with __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__sum_early as ( with source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_early_first) and dekad <= var(sum_early_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ),source as ( select * from __dbt__cte__sum_early ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output"},crop_cal_precast:{name:"crop_cal_precast",query:"SELECT gid, crop, activity, GREATEST((start_time - DATE '2020-01-01')/10, 1) as start_time, GREATEST((end_time - DATE '2020-01-01')/10, 1) as end_time FROM crop_cal_raw WHERE gid='var(region)'"},payout_vegetation_evi:{name:"payout_vegetation_evi",query:"with __dbt__cte__evi as ( with unpivot_result as ( select * from evi_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ), __dbt__cte__vegetation_evi as ( with source as ( select * from __dbt__cte__evi ), intervel as ( select * from source where dekad >= var(vegetation_first) and dekad <= var(vegetation_last) ), rain_window as ( select year, sum(value) *var(scalar_vegetation) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output ),source as ( select * from __dbt__cte__vegetation_evi ), payout_raw as ( select *, case when EXIT_VALUE = TRIGGER_VALUE then 0 else (WINDOW_VALUE - TRIGGER_VALUE)/(EXIT_VALUE - TRIGGER_VALUE) end as payout_value from source ), output as ( select year, case when payout_value < 0 then 0 when payout_value > 1 then 1 else payout_value end as payout from payout_raw ) select * from output"},vegetation_evi:{name:"vegetation_evi",query:"with __dbt__cte__evi as ( with unpivot_result as ( select * from evi_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ),source as ( select * from __dbt__cte__evi ), intervel as ( select * from source where dekad >= var(vegetation_first) and dekad <= var(vegetation_last) ), rain_window as ( select year, sum(value) *var(scalar_vegetation) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output"},sum_late:{name:"sum_late",query:"with __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ),source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_late_first) and dekad <= var(sum_late_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output"},sum_early:{name:"sum_early",query:"with __dbt__cte__chirps as ( with unpivot_result as ( select * from chirps_raw ), gid_map as ( select a.gid, a.year, a.value, a.dekad, b.village from unpivot_result a left join admin_raw b on a.gid = b.gid ), filter_year_admin as ( select * from gid_map where gid = 'var(region)' and YEAR >= var(year_start) and YEAR <= var(year_end) ), cap as ( select *, case when value > var(dekcap) then var(dekcap) else value end as value_cap from filter_year_admin a ), output as ( select * from cap ) select * from output ),source as ( select * from __dbt__cte__chirps ), intervel as ( select * from source where dekad >= var(sum_early_first) and dekad <= var(sum_early_last) ), rain_window as ( select year, sum(value_cap) as window_value from intervel group by year ), trigger_exit as ( select round(percentile_cont(var(freq)) within group (order by window_value asc)) as trigger_value, round(min(window_value)) * var(exit_multiplier) as exit_value from rain_window ), output as ( select * from rain_window cross join trigger_exit order by year ) select * from output"}};function d(a){return a&&a.execute}function i(a){return a&&a.addSourceIact}class w{constructor(e){var _,s;let t=o(n),r=o(c);this.id=e.id,this.m=e.m,this.type=(_=this.m)==null?void 0:_.type,this.space=(s=this.m)==null?void 0:s.space,this.postprocess=e.postprocess??l,this.source=i(e.source)?e.source:t[e.source],this.target=d(e.target)?e.target:r[e.target],i(this.source)?this.source.addSourceIact(this):console.warn("Interaction source doesn't define addSourceIact",this.source)}trigger(e,...t){let r=this.postprocess(e);console.log("let's see iact binding: ",e),this.target.execute(r,...t)}preview(e){throw new Error("Not Implemented")}}const g=u({region:1128,dekcap:24,freq:.23,year_start:1981,year_end:2020,back_fill_year:2001,sum_early_weight:.4,sum_late_weight:.4,vegetation_weight:.6,sum_early_first:1,sum_early_last:30,sum_late_first:1,sum_late_last:30,vegetation_first:10,vegetation_last:30,scalar_vegetation:1,exit_multiplier:.8}),f=u({});export{w as I,f as c,y as m,g as p};
